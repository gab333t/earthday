<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Outlet â€“ Map</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="map.css">
        <link rel="icon" type="image/x-icon" href="img/favicon_light.ico">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Instrument+Sans:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
    </head>
    <body>
        <h1>Map</h1>
        <hr>

        <div class="report-container">
            <h2></h2>
        </div>

        <br>
        <img class="map-box" src="img/map_landscape_white.jpg" alt="Map of Manhattan, partially including Brooklyn" draggable="false">
        <div class="box-container">
            <div class="box" id="electric">
                <div class="box-content">
                    <img src="img/electric_black.png" alt="Black electric symbol, verified alert." draggable="false">
                    <h5>
                        <span class="bold" id="topbold">Scheduled for 10:30 PM, 0.5 miles away<br>Verified by ConEdison<br></span>
                        An electricity outage is scheduled for undergoing renovations underground.
                    </h5>
                </div>
            </div>
        <div class="navigation">
            <div class="logo">
                <img id="logo-icon" src="img/logo_white.png" alt="Outlet Logo" draggable="false">
                <h4 class="bold">Outlet</h4>
                <br><br>
            </div>
            <div class="nav-item">
                <a href="community.html">
                    <img id="comm" src="img/comm_white.png" alt="Community Icon" draggable="false">
                </a>
                <h4>Community</h4>
                <br>
            </div>
            <div class="nav-item" id="gap-left">
                <a href="map.html">
                    <img id="map" src="img/map_white.png" alt="Map Icon" draggable="false">
                </a>
                <h4>Map</h4>
                <br>
            </div>
            <div class="nav-item" id="gap-right">
                <a href="inbox.html">
                    <img id="notif" src="img/notif_white.png" alt="Notification Icon" draggable="false">
                </a>
                <h4>Inbox</h4>
                <br>
            </div>
            <div class="nav-item">
                <a href="settings.html">
                    <img id="settings" src="img/settings_white.png" alt="Settings Icon" draggable="false">
                </a>
                <h4>Settings</h4>
            </div>
        </div>
        <div class="alert-item">
            <a href="index.html">
                <img id="alert" src="img/alert_white.png" alt="Alert Icon" draggable="false">
            </a>
            <div class="alert-circle"></div>
            <div class="alert-bg"></div>
        </div>
    </body>
    <script>
function setFavicon() {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const faviconPath = isDarkMode ? 'img/favicon_dark.ico' : 'img/favicon_light.ico';

    let favicon = document.querySelector("link[rel='icon']");
    if (!favicon) {
        favicon = document.createElement('link');
        favicon.rel = 'icon';
        document.head.appendChild(favicon);
    }
    favicon.href = faviconPath;
}

setFavicon();

window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', setFavicon);

const mapBox = document.querySelector('.map-box');
const container = document.createElement('div');
container.className = 'map-container';

mapBox.parentNode.insertBefore(container, mapBox);
container.appendChild(mapBox);

const zoomControls = document.createElement('div');
zoomControls.className = 'zoom-controls';

const zoomInBtn = document.createElement('button');
zoomInBtn.className = 'zoom-btn zoom-in';
zoomInBtn.setAttribute('aria-label', 'Zoom in');

const zoomOutBtn = document.createElement('button');
zoomOutBtn.className = 'zoom-btn zoom-out';
zoomOutBtn.setAttribute('aria-label', 'Zoom out');

const zoomInImg = document.createElement('img');
zoomInImg.src = 'img/zoomin_light.png';
zoomInImg.className = 'zoom-icon';
zoomInImg.alt = 'Zoom in';
zoomInImg.draggable = false;

const zoomOutImg = document.createElement('img');
zoomOutImg.src = 'img/zoomout_light.png';
zoomOutImg.className = 'zoom-icon';
zoomOutImg.alt = 'Zoom out';
zoomOutImg.draggable = false;

zoomInBtn.appendChild(zoomInImg);
zoomOutBtn.appendChild(zoomOutImg);

zoomControls.appendChild(zoomInBtn);
zoomControls.appendChild(zoomOutBtn);
container.appendChild(zoomControls);

let scale = 1;
const MIN_SCALE = 1;
const MAX_SCALE = 3;
let offsetX = 0;
let offsetY = 0;
let isDragging = false;
let startX, startY;
let currentOffsetX = 0;
let currentOffsetY = 0;
let isAnimating = false;
let animationFrameId = null;
let targetScale = 1;
let targetOffsetX = 0;
let targetOffsetY = 0;

function animateTransform(targetProps, duration = 300) {
    if (isAnimating) {
        cancelAnimationFrame(animationFrameId);
    }
    
    isAnimating = true;
    const startProps = {
        scale: scale,
        offsetX: offsetX,
        offsetY: offsetY
    };
    
    const startTime = performance.now();
    
    function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easeProgress = easeOutCubic(progress);
        
        scale = startProps.scale + (targetProps.scale - startProps.scale) * easeProgress;
        offsetX = startProps.offsetX + (targetProps.offsetX - startProps.offsetX) * easeProgress;
        offsetY = startProps.offsetY + (targetProps.offsetY - startProps.offsetY) * easeProgress;
        
        applyTransform();
        
        if (progress < 1) {
            animationFrameId = requestAnimationFrame(animate);
        } else {
            isAnimating = false;
        }
    }
    
    animationFrameId = requestAnimationFrame(animate);
}

function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
}

function applyTransform() {
    mapBox.style.transform = `scale(${scale}) translate(${offsetX}px, ${offsetY}px) translateZ(0)`;
}

function checkBounds() {
    const maxOffsetX = (scale - 1) * (mapBox.clientWidth / 2) / scale;
    const maxOffsetY = (scale - 1) * (mapBox.clientHeight / 2) / scale;
    
    targetOffsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, targetOffsetX));
    targetOffsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, targetOffsetY));
    
    if (targetScale <= MIN_SCALE) {
        targetOffsetX = 0;
        targetOffsetY = 0;
    }
}

zoomInBtn.addEventListener('click', () => {
    if (scale < MAX_SCALE) {
        targetScale = Math.min(scale + 0.5, MAX_SCALE);
        checkBounds();
        animateTransform({
            scale: targetScale,
            offsetX: targetOffsetX,
            offsetY: targetOffsetY
        });
    }
});

zoomOutBtn.addEventListener('click', () => {
    if (scale > MIN_SCALE) {
        targetScale = Math.max(scale - 0.5, MIN_SCALE);
        checkBounds();
        animateTransform({
            scale: targetScale,
            offsetX: targetOffsetX,
            offsetY: targetOffsetY
        });
    }
});

let lastDistance = 0;
let initialScale = 1;
let initialOffsetX = 0;
let initialOffsetY = 0;
let midX = 0;
let midY = 0;

mapBox.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
        isDragging = true;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        currentOffsetX = offsetX;
        currentOffsetY = offsetY;
        e.preventDefault();
    } else if (e.touches.length === 2) {
        isDragging = false;
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        
        lastDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
        );
        
        midX = (touch1.clientX + touch2.clientX) / 2;
        midY = (touch1.clientY + touch2.clientY) / 2;
        
        initialScale = scale;
        initialOffsetX = offsetX;
        initialOffsetY = offsetY;
        
        e.preventDefault();
    }
}, { passive: false });

mapBox.addEventListener('touchmove', (e) => {
    if (isAnimating) {
        cancelAnimationFrame(animationFrameId);
        isAnimating = false;
    }
    
    if (isDragging && e.touches.length === 1) {
        const dx = (e.touches[0].clientX - startX) / scale;
        const dy = (e.touches[0].clientY - startY) / scale;
        
        offsetX = currentOffsetX + dx;
        offsetY = currentOffsetY + dy;
        
        const maxOffsetX = (scale - 1) * (mapBox.clientWidth / 2) / scale;
        const maxOffsetY = (scale - 1) * (mapBox.clientHeight / 2) / scale;
        
        offsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, offsetX));
        offsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, offsetY));
        
        applyTransform();
        e.preventDefault();
    } else if (e.touches.length === 2) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        
        const newDistance = Math.hypot(
            touch2.clientX - touch1.clientX,
            touch2.clientY - touch1.clientY
        );
        
        const newMidX = (touch1.clientX + touch2.clientX) / 2;
        const newMidY = (touch1.clientY + touch2.clientY) / 2;
        
        const scaleChange = newDistance / lastDistance;
        const newScale = Math.min(Math.max(initialScale * scaleChange, MIN_SCALE), MAX_SCALE);
        
        scale = newScale;
        
        offsetX = initialOffsetX + (midX - newMidX) / scale;
        offsetY = initialOffsetY + (midY - newMidY) / scale;
        
        const maxOffsetX = (scale - 1) * (mapBox.clientWidth / 2) / scale;
        const maxOffsetY = (scale - 1) * (mapBox.clientHeight / 2) / scale;
        
        offsetX = Math.max(-maxOffsetX, Math.min(maxOffsetX, offsetX));
        offsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, offsetY));
        
        applyTransform();
        e.preventDefault();
    }
}, { passive: false });

mapBox.addEventListener('touchend', (e) => {
    if (e.touches.length === 0) {
        isDragging = false;
        
        if (scale < MIN_SCALE + 0.1) {
            animateTransform({
                scale: MIN_SCALE,
                offsetX: 0,
                offsetY: 0
            });
        }
    }
});

let lastTap = 0;
mapBox.addEventListener('touchend', (e) => {
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;
    
    if (tapLength < 300 && tapLength > 0 && e.touches.length === 0) {
        if (scale < MAX_SCALE - 0.1) {
            targetScale = Math.min(scale * 2, MAX_SCALE);
            
            if (e.changedTouches && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                const rect = mapBox.getBoundingClientRect();
                
                const tapX = touch.clientX - rect.left - rect.width / 2;
                const tapY = touch.clientY - rect.top - rect.height / 2;
                
                targetOffsetX = offsetX - tapX / (scale * rect.width) * 2;
                targetOffsetY = offsetY - tapY / (scale * rect.height) * 2;
            } else {
                targetOffsetX = offsetX;
                targetOffsetY = offsetY;
            }
        } else {
            targetScale = MIN_SCALE;
            targetOffsetX = 0;
            targetOffsetY = 0;
        }
        
        checkBounds();
        animateTransform({
            scale: targetScale,
            offsetX: targetOffsetX,
            offsetY: targetOffsetY
        });
        
        e.preventDefault();
    }
    
    lastTap = currentTime;
});

mapBox.addEventListener('wheel', (e) => {
    e.preventDefault();
    
    if (isAnimating) {
        cancelAnimationFrame(animationFrameId);
        isAnimating = false;
    }
    
    const rect = mapBox.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const wheelDelta = e.deltaY < 0 ? 1 : -1;
    targetScale = Math.min(Math.max(scale + wheelDelta * 0.2, MIN_SCALE), MAX_SCALE);
    
    if (targetScale !== scale) {
        const cursorX = mouseX - rect.width / 2;
        const cursorY = mouseY - rect.height / 2;
        
        targetOffsetX = offsetX - cursorX / (scale * rect.width) * (targetScale - scale) * 2;
        targetOffsetY = offsetY - cursorY / (scale * rect.height) * (targetScale - scale) * 2;
        
        checkBounds();
        animateTransform({
            scale: targetScale,
            offsetX: targetOffsetX,
            offsetY: targetOffsetY
        });
    }
    
    mapBox.style.cursor = targetScale > MIN_SCALE ? 'grab' : 'default';
}, { passive: false });

document.addEventListener('mouseup', () => {
    isDragging = false;
    mapBox.style.cursor = scale > MIN_SCALE ? 'grab' : 'default';
});

function updateZoomIcons() {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    const zoomInIcon = document.querySelector('.zoom-in .zoom-icon');
    zoomInIcon.src = isDarkMode ? 'img/zoomin_dark.png' : 'img/zoomin_light.png';
    
    const zoomOutIcon = document.querySelector('.zoom-out .zoom-icon');
    zoomOutIcon.src = isDarkMode ? 'img/zoomout_dark.png' : 'img/zoomout_light.png';
}

updateZoomIcons();
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', updateZoomIcons);

applyTransform();
    </script>
</html>